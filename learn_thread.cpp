
/*
ПОТОКИ
-Всегда в процессе есть хотя бы один поток, тогда все действия просто будут последовательными
-С помощью потоков обеспечиваем параллельность
cout << this_thread::get_id(); выводит число, которое является идентификатором текущего потока
this_thread::sleep_for(chrono::milliseconds(1000)) приостанавливает работу текущего потока на определенное время(в миллисекундах)
-Сколько ядер в процессоре, столько потоков может одновременно выполняться, у меня 4
-если не сделать detach/join программа попытается закрыться после завершения main и мы получим ошибку, потому что это не получится
-Если данных мало, то с потоками программа будет работать дольше, 
потому что на создание потоков и распределение уйдет больше времени, чем на получение и обработку данных
-Чем больше данных, тем больше необходимость распределить

-Лямбда-функции(анонимные функции) []() {}; - синтаксис
[] - функция изолирована от внешнего контекста, но если мы захотим обратиться к каким-либо объектам внутри нее, то нам нужно будет захватить объект из внешнего в лямбду и передать в [] этот объект по ссылке
() - параметры функции
{} - само тело функции
-Функция является анонимной, потому что имени у нее нет, ее никак не вызвать по имени, но мы можем параметром передать ее в другую функцию

-async([]{}); - функция, которая запускает асинхронную операцию / она принимает другую функцию, которую запустит асинхронно, в данном случае лямбда
-async возвращает future
- .get() таким образом мы получаем результат асинхронного программирования
На примере сложения двух векторов:
int SumVectors (const vector<int>& one, const vector<int>& two) {
    future<int> f = async([&one] { //лямбда будет возвращать int, поэтому async должен вернуть future<int>
        return accumulate(begin(one), end(one), 0);
    });
    int result = accumulate(begin(two), end(two), 0);
    return result + f.get();
}
-В общем виде синтаксис async следующий:
std::future<T> async(launch policy, function<T()>&& fn);
launch policy - политика запуска (например, launch::async для немедленного запуска)
function<T()>&& fn - лямбда-функция или другой вызываемый объект, который не возвращает значения

-chrono::high_resolution_clock::now() функция вовращает момент времени при ее вызове
-chrono::duration_cast<chrono::nanoseconds>(end - start) преобразует разницу между end и start в указанную единицу времени, в данном случае в наносекунды
*/